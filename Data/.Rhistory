tail_train_df
kendall_matrix
# Funzione per il grafico con titoli più leggibili
plot_tail_dependence <- function(u, v, name1, name2) {
ggplot(data.frame(u = u, v = v), aes(x = u, y = v)) +
geom_point(alpha = 0.3, color = "steelblue") +
geom_vline(xintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
geom_hline(yintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
labs(title = paste("Tail Dependence: ", name1, "vs", name2),
x = paste(name1, "(PIT)"), y = paste(name2, "(PIT)")) +
theme_minimal(base_size = 12)
}
# Genera tutti i plot per ogni coppia
tail_plots <- lapply(pairs_u, function(pair) {
plot_tail_dependence(U_matrix[[pair[1]]], U_matrix[[pair[2]]], pair[1], pair[2])
})
library(ggplot)
library(ggplot2)
# Funzione per il grafico con titoli più leggibili
plot_tail_dependence <- function(u, v, name1, name2) {
ggplot(data.frame(u = u, v = v), aes(x = u, y = v)) +
geom_point(alpha = 0.3, color = "steelblue") +
geom_vline(xintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
geom_hline(yintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
labs(title = paste("Tail Dependence: ", name1, "vs", name2),
x = paste(name1, "(PIT)"), y = paste(name2, "(PIT)")) +
theme_minimal(base_size = 12)
}
# Genera tutti i plot per ogni coppia
tail_plots <- lapply(pairs_u, function(pair) {
plot_tail_dependence(U_matrix[[pair[1]]], U_matrix[[pair[2]]], pair[1], pair[2])
})
# Visualizza tutti i grafici in una griglia 2x3 (se 6 coppie)
plot_grid(plotlist = tail_plots, ncol = 2)
library(dplyr)
library(ggplot2)
library(xts)
library(tidyr)
library(moments)
library(tseries)
library(forecast)
library(MASS)
library(copula)
library(rugarch)
library(xts)
library(nortest)
library(fitdistrplus)
library(stats)
library(tseries)
library(FinTS)
library(GGally)
library(gridExtra)
library(profvis)
library(parallel)
library(patchwork)
library(zoo)
# Funzione per il grafico con titoli più leggibili
plot_tail_dependence <- function(u, v, name1, name2) {
ggplot(data.frame(u = u, v = v), aes(x = u, y = v)) +
geom_point(alpha = 0.3, color = "steelblue") +
geom_vline(xintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
geom_hline(yintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
labs(title = paste("Tail Dependence: ", name1, "vs", name2),
x = paste(name1, "(PIT)"), y = paste(name2, "(PIT)")) +
theme_minimal(base_size = 12)
}
# Genera tutti i plot per ogni coppia
tail_plots <- lapply(pairs_u, function(pair) {
plot_tail_dependence(U_matrix[[pair[1]]], U_matrix[[pair[2]]], pair[1], pair[2])
})
# Visualizza tutti i grafici in una griglia 2x3 (se 6 coppie)
plot_grid(plotlist = tail_plots, ncol = 2)
library(tidyr)
library(cowplot)
# Funzione per il grafico con titoli più leggibili
plot_tail_dependence <- function(u, v, name1, name2) {
ggplot(data.frame(u = u, v = v), aes(x = u, y = v)) +
geom_point(alpha = 0.3, color = "steelblue") +
geom_vline(xintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
geom_hline(yintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
labs(title = paste("Tail Dependence: ", name1, "vs", name2),
x = paste(name1, "(PIT)"), y = paste(name2, "(PIT)")) +
theme_minimal(base_size = 12)
}
# Genera tutti i plot per ogni coppia
tail_plots <- lapply(pairs_u, function(pair) {
plot_tail_dependence(U_matrix[[pair[1]]], U_matrix[[pair[2]]], pair[1], pair[2])
})
# Visualizza tutti i grafici in una griglia 2x3 (se 6 coppie)
plot_grid(plotlist = tail_plots, ncol = 2)
# Funzione per il grafico con titoli più leggibili
plot_tail_dependence <- function(u, v, name1, name2) {
ggplot(data.frame(u = u, v = v), aes(x = u, y = v)) +
geom_point(alpha = 0.3, color = "black") +
geom_vline(xintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
geom_hline(yintercept = c(0.05, 0.95), linetype = "dashed", color = "red") +
labs(title = paste("Tail Dependence: ", name1, "vs", name2),
x = paste(name1, "(PIT)"), y = paste(name2, "(PIT)")) +
theme_minimal(base_size = 12)
}
# Genera tutti i plot per ogni coppia
tail_plots <- lapply(pairs_u, function(pair) {
plot_tail_dependence(U_matrix[[pair[1]]], U_matrix[[pair[2]]], pair[1], pair[2])
})
# Visualizza tutti i grafici in una griglia 2x3 (se 6 coppie)
plot_grid(plotlist = tail_plots, ncol = 2)
window_size1 <- 500
step1 <- 1
n_obs1 <- nrow(X_tot)
dates1 <- index(X_tot)  # usa zoo/xts se hai date
series1 <- colnames(X_tot)
pairs1 <- combn(series1, 2, simplify = FALSE)
pair_names1 <- sapply(pairs1, function(p) paste(p, collapse = " - "))
# Init
kendall_list1 <- list()
lower_tail_list1 <- list()
upper_tail_list1 <- list()
date_labels1 <- c()
for (start in seq(1, n_obs1 - window_size1 + 1, by = step1)) {
end <- start + window_size1 - 1
window_data <- X_tot[start:end, ]
# PIT: rank transformation (uniforme)
U_window <- apply(window_data, 2, function(x) rank(x) / (length(x) + 1))
U_window <- as.data.frame(U_window)
tau_row <- c()
lower_row <- c()
upper_row <- c()
for (pair in pairs1) {
u <- U_window[[pair[1]]]
v <- U_window[[pair[2]]]
tau_row <- c(tau_row, cor(u, v, method = "kendall", use = "pairwise.complete.obs"))
lower_row <- c(lower_row, lower_tail_dep(u, v))
upper_row <- c(upper_row, upper_tail_dep(u, v))
}
kendall_list1[[length(kendall_list1) + 1]] <- tau_row
lower_tail_list1[[length(lower_tail_list1) + 1]] <- lower_row
upper_tail_list1[[length(upper_tail_list1) + 1]] <- upper_row
date_labels1 <- c(date_labels1, dates1[end])
}
# Convert to data frames
kendall_rolling_df1 <- data.frame(Date = date_labels1, do.call(rbind, kendall_list1))
colnames(kendall_rolling_df1)[-1] <- pair_names1
lower_tail_df1 <- data.frame(Date = date_labels1, do.call(rbind, lower_tail_list1))
colnames(lower_tail_df1)[-1] <- pair_names1
upper_tail_df1 <- data.frame(Date = date_labels1, do.call(rbind, upper_tail_list1))
colnames(upper_tail_df1)[-1] <- pair_names1
kendall_rolling_df1
kendall_long1 <- pivot_longer(kendall_rolling_df1, -Date, names_to = "Pair", values_to = "Tau")
p1 <- ggplot(kendall_long1, aes(x = Date, y = Tau, color = Pair)) +
geom_line() +
labs(title = "Evoluzione di Kendall's Tau",
y = "Tau di Kendall", x = NULL) +
theme_minimal() +
theme(legend.position = "bottom")
# 2. Lower tail dependence
lower_long1 <- pivot_longer(lower_tail_df1, -Date, names_to = "Pair", values_to = "LowerTail")
p2 <- ggplot(lower_long1, aes(x = Date, y = LowerTail, color = Pair)) +
geom_line() +
labs(title = "Lower Tail Dependence (λ_L)",
y = "λ_L", x = NULL) +
theme_minimal() +
theme(legend.position = "bottom")
# 3. Upper tail dependence
upper_long1 <- pivot_longer(upper_tail_df1, -Date, names_to = "Pair", values_to = "UpperTail")
p3 <- ggplot(upper_long1, aes(x = Date, y = UpperTail, color = Pair)) +
geom_line() +
labs(title = "Upper Tail Dependence (λ_U)",
y = "λ_U", x = NULL) +
theme_minimal() +
theme(legend.position = "bottom")
p1
p2
p3
source("C:/Users/giuse/OneDrive/Desktop/Preparazione tesi/Thesis Code/DEPENDENCE_ANALYSIS.R")
ad.test(X$ITA)
library(dplyr)
library(ggplot2)
library(xts)
library(tidyr)
library(moments)
library(tseries)
library(forecast)
library(MASS)
library(copula)
library(rugarch)
library(xts)
library(nortest)
library(fitdistrplus)
library(stats)
library(tseries)
library(FinTS)
library(GGally)
library(gridExtra)
library(profvis)
library(parallel)
library(patchwork)
library(zoo)
ad.test(X$ITA)
shapiro.test(X$ITA)
par(mfrow = c(2, 2))
pacf(X$ITA, main="PACF ITA")
pacf(X$GER, main="PACF GER")
pacf(X$FRA, main="PACF FRA")
pacf(X$SPA, main="PACF SPA")
par(mfrow = c(1, 1))
acf(X$ITA,main="ACF ITA")
acf(X$GER,  main="ACF GER")
acf(X$FRA,  main="ACF FRA")
acf(X$SPA,  main="ACF SPA")
fit_ITA
risultato_ITA
# ---------Select best AR-GARCH model -----------
selection_optimal_ar_garch <- function(series, alpha = .1) {
# Check input validity
if(!is.ts(series) && !is.numeric(series)) {
stop("Input must be a time series or numeric vector")
}
if(!is.ts(series)) {
series <- as.ts(series)
}
# Define the list of GARCH models to test
models <- list(
list(type = "sGARCH", submodel = NULL),
list(type = "eGARCH", submodel = NULL),
list(type = "gjrGARCH", submodel = NULL),
list(type = "fGARCH", submodel = "TGARCH"),
list(type = "fGARCH", submodel = "AVGARCH")
)
# Set the innovation distributions and AR orders
distributions <- c("norm", "std", "sstd")
ar_orders <- 0:5
all_models <- list()
model_count <- 0
# Loop over all combinations of model, AR order, and distribution
for(model_info in models) {
for(ar_p in ar_orders) {
for(dist_type in distributions) {
model_type <- model_info$type
submodel <- model_info$submodel
model_name <- ifelse(
is.null(submodel),
paste0(model_type, "-", dist_type, "-AR(", ar_p, ")"),
paste0(model_type, "-", submodel, "-", dist_type, "-AR(", ar_p, ")")
)
cat("\nEstimating model:", model_name, "\n")
tryCatch({
# Create model specification
spec <- ugarchspec(
variance.model = list(model = model_type, garchOrder = c(1, 1), submodel = submodel),
mean.model = list(armaOrder = c(ar_p, 0), include.mean = TRUE),
distribution.model = dist_type
)
cat("Specification created. Starting estimation...\n")
# Fit the model
fit <- ugarchfit(spec = spec, data = series, solver = "hybrid")
model_count <- model_count + 1
bic_value <- infocriteria(fit)[2,1]  # Extract BIC
cat("BIC:", bic_value, "\n")
all_models[[model_count]] <- list(
fit = fit,
name = model_name,
bic = bic_value,
distribution = dist_type
)
}, error = function(e) {
cat("Estimation error:", e$message, "\n")
})
}
}
}
# Check if any model was successfully estimated
if(model_count == 0) {
cat("No model was successfully estimated!\n")
return(NULL)
}
cat("\nSuccessfully estimated models:", model_count, "out of 90 models tested.\n")
# Sort models by BIC
bic_values <- sapply(all_models, function(x) x$bic)
order_idx <- order(bic_values)
sorted_models <- all_models[order_idx]
# Select top 4 models by BIC
top_n <- min(4, length(sorted_models))
top_models <- sorted_models[1:top_n]
# Function to apply diagnostic tests to a fitted model
test_model <- function(model) {
std_resid <- residuals(model$fit, standardize = TRUE)
# ARCH-LM test for residual heteroscedasticity
arch_test <- FinTS::ArchTest(std_resid, lags = 10)
arch_pvalue <- arch_test$p.value
if(arch_pvalue < alpha) {
cat("Model", model$name, "fails ARCH-LM test (p =", round(arch_pvalue, 4), ")\n")
} else {
cat("Model", model$name, "passes ARCH-LM test (p =", round(arch_pvalue, 4), ")\n")
}
# Ljung-Box test for autocorrelation in standardized residuals
lb_test <- Box.test(std_resid, lag = 20, type = "Ljung-Box")
lb_pvalue <- lb_test$p.value
if(lb_pvalue < alpha) {
cat("Model", model$name, "fails Ljung-Box test (p =", round(lb_pvalue, 4), ")\n")
} else {
cat("Model", model$name, "passes Ljung-Box test (p =", round(lb_pvalue, 4), ")\n")
}
# PIT transformation for uniformity test
if(model$distribution == "norm") {
pit_values <- pnorm(std_resid)
} else if(model$distribution == "std") {
shape <- coef(model$fit)["shape"]
pit_values <- pt(std_resid, df = shape)
} else if(model$distribution == "sstd") {
shape <- coef(model$fit)["shape"]
skew <- coef(model$fit)["skew"]
pit_values <- rugarch::pdist("sstd", q = std_resid, shape = shape, skew = skew)
}
# Kolmogorov-Smirnov test for uniformity of PITs
ks_test <- ks.test(pit_values, "punif")
ks_pvalue <- ks_test$p.value
if(ks_pvalue < alpha) {
cat("Model", model$name, "fails KS test (p =", round(ks_pvalue, 4), ")\n")
} else {
cat("Model", model$name, "passes KS test (p =", round(ks_pvalue, 4), ")\n")
}
# Return TRUE only if all tests are passed
return(all(c(arch_pvalue, lb_pvalue, ks_pvalue) >= alpha))
}
# Evaluate diagnostic tests on top 4 BIC models
valid_model_found <- FALSE
best_model <- NULL
for (i in seq_along(top_models)) {
model <- top_models[[i]]
cat("\nEvaluating candidate model", i, ":", model$name, "(BIC =", model$bic, ")\n")
if (test_model(model)) {
cat("Model", model$name, "is the best among the top 4 BIC models\n")
best_model <- model$fit
valid_model_found <- TRUE
break
} else {
cat("Model", model$name, "did not pass all diagnostic tests\n")
}
}
# Warning if no model passed all diagnostics
if (!valid_model_found) {
cat("\nNone of the top 4 BIC models passed all diagnostic tests.\n")
}
# Return results
return(list(
best_model = best_model,
top_models = lapply(top_models, function(x) x$fit),
top_model_names = sapply(top_models, function(x) x$name),
model_count = model_count
))
}
risultato_ITA <- selection_optimal_ar_garch(X$ITA)
risultato_GER <- selection_optimal_ar_garch(X$GER)
risultato_FRA <- selection_optimal_ar_garch(X$FRA)
risultato_SPA <- selection_optimal_ar_garch(X$SPA)
risultato_ITA
risultato_GER
risultato_FRA
risultato_SPA
risultato_ITA
mu1ts <- resids_df$FTSEMIB
mu2ts <- resids_df$DAX
mu3ts <- resids_df$CAC
mu4ts <- resids_df$IBEX
resids_df$FTSEMIB
sinkhorn_mot_4 <- function(mu1, mu2, mu3, mu4, C, epsilon, maxIter, tol) {
n1 <- length(mu1); n2 <- length(mu2); n3 <- length(mu3); n4 <- length(mu4)
stopifnot(dim(C) == c(n1, n2, n3, n4))
stopifnot(all(abs(c(sum(mu1), sum(mu2), sum(mu3), sum(mu4)) - 1) < 1e-8))
u1 <- rep(1, n1); u2 <- rep(1, n2); u3 <- rep(1, n3); u4 <- rep(1, n4)
C_scaled <- C / mean(C)
K <- exp(-C_scaled / epsilon)
for (iter in 1:maxIter) {
u1_old <- u1; u2_old <- u2; u3_old <- u3; u4_old <- u4
for (i in 1:n1) {
temp <- K[i,,,,drop=FALSE]
marginal <- sum(temp * array(rep(u2, each=n3*n4), dim=c(1,n2,n3,n4)) *
array(rep(u3, each=n2*n4), dim=c(1,n2,n3,n4)) *
array(rep(u4, each=n2*n3), dim=c(1,n2,n3,n4)))
u1[i] <- mu1[i] / (marginal + .Machine$double.eps)
}
for (j in 1:n2) {
temp <- K[,j,,,drop=FALSE]
marginal <- sum(temp * array(rep(u1, each=n3*n4), dim=c(n1,1,n3,n4)) *
array(rep(u3, each=n1*n4), dim=c(n1,1,n3,n4)) *
array(rep(u4, each=n1*n3), dim=c(n1,1,n3,n4)))
u2[j] <- mu2[j] / (marginal + .Machine$double.eps)
}
for (k in 1:n3) {
temp <- K[,,k,,drop=FALSE]
marginal <- sum(temp * array(rep(u1, each=n2*n4), dim=c(n1,n2,1,n4)) *
array(rep(u2, each=n1*n4), dim=c(n1,n2,1,n4)) *
array(rep(u4, each=n1*n2), dim=c(n1,n2,1,n4)))
u3[k] <- mu3[k] / (marginal + .Machine$double.eps)
}
for (l in 1:n4) {
temp <- K[,,,l,drop=FALSE]
marginal <- sum(temp * array(rep(u1, each=n2*n3), dim=c(n1,n2,n3,1)) *
array(rep(u2, each=n1*n3), dim=c(n1,n2,n3,1)) *
array(rep(u3, each=n1*n2), dim=c(n1,n2,n3,1)))
u4[l] <- mu4[l] / (marginal + .Machine$double.eps)
}
err <- max(
norm(u1 - u1_old, type = "2") / (norm(u1_old, type = "2") + .Machine$double.eps),
norm(u2 - u2_old, type = "2") / (norm(u2_old, type = "2") + .Machine$double.eps),
norm(u3 - u3_old, type = "2") / (norm(u3_old, type = "2") + .Machine$double.eps),
norm(u4 - u4_old, type = "2") / (norm(u4_old, type = "2") + .Machine$double.eps)
)
cat(sprintf("Iter %d, Error: %.6f\n", iter, err))
if (err < tol) break
}
pi_matrix <- array(0, dim=dim(K))
for (i in 1:n1) for (j in 1:n2) for (k in 1:n3) for (l in 1:n4)
pi_matrix[i,j,k,l] <- K[i,j,k,l] * u1[i] * u2[j] * u3[k] * u4[l]
pi_matrix <- pi_matrix / sum(pi_matrix)
list(pi_opt = as.vector(pi_matrix), pi_matrix = pi_matrix)
}
sinkhorn_mot_4 <- function(mu1, mu2, mu3, mu4, C, epsilon, maxIter, tol) {
n1 <- length(mu1); n2 <- length(mu2); n3 <- length(mu3); n4 <- length(mu4)
stopifnot(dim(C) == c(n1, n2, n3, n4))
stopifnot(all(abs(c(sum(mu1), sum(mu2), sum(mu3), sum(mu4)) - 1) < 1e-8))
u1 <- rep(1, n1); u2 <- rep(1, n2); u3 <- rep(1, n3); u4 <- rep(1, n4)
C_scaled <- C / mean(C)
K <- exp(-C_scaled / epsilon)
for (iter in 1:maxIter) {
u1_old <- u1; u2_old <- u2; u3_old <- u3; u4_old <- u4
for (i in 1:n1) {
temp <- K[i,,,,drop=FALSE]
marginal <- sum(temp * array(rep(u2, each=n3*n4), dim=c(1,n2,n3,n4)) *
array(rep(u3, each=n2*n4), dim=c(1,n2,n3,n4)) *
array(rep(u4, each=n2*n3), dim=c(1,n2,n3,n4)))
u1[i] <- mu1[i] / (marginal + .Machine$double.eps)
}
for (j in 1:n2) {
temp <- K[,j,,,drop=FALSE]
marginal <- sum(temp * array(rep(u1, each=n3*n4), dim=c(n1,1,n3,n4)) *
array(rep(u3, each=n1*n4), dim=c(n1,1,n3,n4)) *
array(rep(u4, each=n1*n3), dim=c(n1,1,n3,n4)))
u2[j] <- mu2[j] / (marginal + .Machine$double.eps)
}
for (k in 1:n3) {
temp <- K[,,k,,drop=FALSE]
marginal <- sum(temp * array(rep(u1, each=n2*n4), dim=c(n1,n2,1,n4)) *
array(rep(u2, each=n1*n4), dim=c(n1,n2,1,n4)) *
array(rep(u4, each=n1*n2), dim=c(n1,n2,1,n4)))
u3[k] <- mu3[k] / (marginal + .Machine$double.eps)
}
for (l in 1:n4) {
temp <- K[,,,l,drop=FALSE]
marginal <- sum(temp * array(rep(u1, each=n2*n3), dim=c(n1,n2,n3,1)) *
array(rep(u2, each=n1*n3), dim=c(n1,n2,n3,1)) *
array(rep(u3, each=n1*n2), dim=c(n1,n2,n3,1)))
u4[l] <- mu4[l] / (marginal + .Machine$double.eps)
}
err <- max(
norm(u1 - u1_old, type = "2") / (norm(u1_old, type = "2") + .Machine$double.eps),
norm(u2 - u2_old, type = "2") / (norm(u2_old, type = "2") + .Machine$double.eps),
norm(u3 - u3_old, type = "2") / (norm(u3_old, type = "2") + .Machine$double.eps),
norm(u4 - u4_old, type = "2") / (norm(u4_old, type = "2") + .Machine$double.eps)
)
cat(sprintf("Iter %d, Error: %.6f\n", iter, err))
if (err < tol) break
}
pi_matrix <- array(0, dim=dim(K))
for (i in 1:n1) for (j in 1:n2) for (k in 1:n3) for (l in 1:n4)
pi_matrix[i,j,k,l] <- K[i,j,k,l] * u1[i] * u2[j] * u3[k] * u4[l]
pi_matrix <- pi_matrix / sum(pi_matrix)
list(pi_opt = as.vector(pi_matrix), pi_matrix = pi_matrix)
}
### MAIN SCRIPT
# Load residuals
mu1ts <- resids_df$FTSEMIB
mu2ts <- resids_df$DAX
mu3ts <- resids_df$CAC
mu4ts <- resids_df$IBEX
# Histogram binning
punti <- 30
bins1 <- seq(min(mu1ts), max(mu1ts), length.out = punti)
bins2 <- seq(min(mu2ts), max(mu2ts), length.out = punti)
bins3 <- seq(min(mu3ts), max(mu3ts), length.out = punti)
bins4 <- seq(min(mu4ts), max(mu4ts), length.out = punti)
mu1 <- hist(mu1ts, breaks=c(bins1, Inf), plot=FALSE)$density
mu2 <- hist(mu2ts, breaks=c(bins2, Inf), plot=FALSE)$density
mu3 <- hist(mu3ts, breaks=c(bins3, Inf), plot=FALSE)$density
mu4 <- hist(mu4ts, breaks=c(bins4, Inf), plot=FALSE)$density
# Normalize to sum to 1
mu1 <- mu1 / sum(mu1); mu2 <- mu2 / sum(mu2)
mu3 <- mu3 / sum(mu3); mu4 <- mu4 / sum(mu4)
# Cost tensor
grid <- expand.grid(bins1, bins2, bins3, bins4)
X1 <- array(grid[,1], dim=c(punti, punti, punti, punti))
X2 <- array(grid[,2], dim=c(punti, punti, punti, punti))
X3 <- array(grid[,3], dim=c(punti, punti, punti, punti))
X4 <- array(grid[,4], dim=c(punti, punti, punti, punti))
C <- (X1 - X2)^2 + (X1 - X3)^2 + (X1 - X4)^2 +
(X2 - X3)^2 + (X2 - X4)^2 + (X3 - X4)^2
# Sinkhorn
result_sink <- sinkhorn_mot_4(mu1, mu2, mu3, mu4, C, epsilon = 0.001, maxIter = 2500, tol = 1e-6)
pi_matrix <- result$pi_matrix
result_sink
pi_matrix <- result_sink$pi_matrix
pi_matrix
set.seed(42)
inds <- sample(length(pi_matrix), size = 10000, replace = TRUE, prob = as.vector(pi_matrix))
idx <- arrayInd(inds, .dim = dim(pi_matrix))
samples <- data.table(
ITA = bins1[idx[,1]],
GER = bins2[idx[,2]],
FRA = bins3[idx[,3]],
SPA = bins4[idx[,4]]
)
source("C:/Users/giuse/OneDrive/Desktop/Preparazione tesi/Thesis Code/1_Preliminar_analysis.R")
